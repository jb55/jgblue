<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Item not found | JGBlue | JGBlue</title>
<link href="http://dstatic.jgblue.com/css/style.css?6" rel="stylesheet" type="text/css" />
<script src="http://dstatic.jgblue.com/js/jquery-1.3.2.js" type="text/javascript"></script>
<script src="http://dstatic.jgblue.com/js/main.js?6" type="text/javascript"></script>
<script src="http://dstatic.jgblue.com/o3djs/base.js" type="text/javascript"></script>
<script src="http://dstatic.jgblue.com/js/jgblue-3d.js?6" type="text/javascript" id="o3dscript"></script>
</head>
<body>
<div id="container">
    <div id="banner-left">
    	<a href="/" title="JGblue - A Jumpgate Evolution Database">
        <img class="logo" src="http://dstatic.jgblue.com/img/jgblue_logo.png" alt="JGblue - A Jumpgate Evolution Database" width="196" height="45"/>
        </a>
    </div>
    <div id="menu">
    	<ul class="menulist">
            <li class="first"><a href="/items">Items</a></li>
        	<li><a href="/#">Medals</a></li>
            <li><a href="/#">Spacecraft</a></li>
        </ul>
    </div>
    <div id="context">
    	<ul>
        <li class="first">
                    Database
                </li><li><a href="/items">Items</a></li>
        </ul>
    </div>
    <div id="content-wrap">
    	<div id="content">
            <h1>o3d test</h1>
            <div id="o3d" style="width: 600px; height: 600px;"></div>
<!-- Don't render the textarea -->
<div style="display:none">
<!-- Start of effect -->
<textarea id="effect" name="effect" cols="80" rows="20"
       style="display: none;">
uniform float4x4 world : WORLD;
uniform float4x4 worldViewProjection : WORLDVIEWPROJECTION;
uniform float4x4 worldInverseTranspose : WORLDINVERSETRANSPOSE;
uniform float clock;
uniform float3 lightWorldPos;
uniform float3 cameraWorldPos;


// Input parameters for the vertex shader.
struct VertexShaderInput {
  float4 position : POSITION;
  float3 normal : NORMAL;
  float4 color : COLOR;
};


// Input parameters for the pixel shader (also the output parameters for the
// vertex shader.)
struct PixelShaderInput {
  float4 position : POSITION;          // the position in clip space
  float3 objectPosition : TEXCOORD0;   // the position in world space
  float3 normal : TEXCOORD1;           // the normal in world space
  float4 color : COLOR;
};


/**
 * A function defining the shape of the wave.  Takes a single float2 as an
 * argument the entries of which are the x and z components of a point in the
 * plane.  Returns the height of that point.
 *
 * @param {float2} v The x and z components of the point in a single float2.
 */
float wave(float2 v) {
  float d = length(v);
  return 0.15 * sin(15 * d - 5 * clock) / (1 + d * d);
}


/**
 * vertexShaderFunction - The vertex shader perturbs the vertices of the plane
 * to achieve the ripples.  Then it applies the worldViewProjection matrix.
 *
 * @param input.position Position vector of vertex in object coordinates.
 * @param input.normal Normal of vertex in object coordinates.
 * @param input.color Color of vertex.
 */
PixelShaderInput vertexShaderFunction(VertexShaderInput input) {
  PixelShaderInput output;

  float4 p = input.position;

  // The height of the point p is adjusted according to the wave function.
  p.y = wave(p.xz);

  // Step size used to approximate the partial derivatives of the wave function.
  float h = 0.001;

  // We take the derivative numerically so that the wave function can be
  // modified and the normal will still be correct.
  float3 n = normalize(float3(
      wave(float2(p.x - h, p.z)) - wave(float2(p.x + h, p.z)), 2 * h,
      wave(float2(p.x, p.z - h)) - wave(float2(p.x, p.z + h))));

  output.position = mul(p, worldViewProjection);
  output.objectPosition = mul(p, world).xyz;
  output.normal = mul(float4(n, 1), worldInverseTranspose).xyz;
  output.color = input.color;

  return output;
}


/**
 * This pixel shader is meant to be minimal since the vertex shader is
 * the focus of the sample.
 */
float4 pixelShaderFunction(PixelShaderInput input) : COLOR {
  float3 p = input.objectPosition;          // The point in question.
  float3 l = normalize(lightWorldPos - p);  // Unit-length vector toward light.
  float3 n = normalize(input.normal);       // Unit-length normal vector.
  float3 v = normalize(cameraWorldPos - p); // Unit-length vector toward camera.
  float3 r = normalize(-reflect(v, n));     // Reflection of v across n.

  float3 q = (lightWorldPos - p);
  float ldotr = dot(r, l);
  float specular = clamp(ldotr, 0, 1) /
      (1 + length(q - length(q) * ldotr * r));

  return float4(0, 0.6, 0.7, 1) * dot(n, l) + specular;
}


// #o3d VertexShaderEntryPoint vertexShaderFunction
// #o3d PixelShaderEntryPoint pixelShaderFunction
// #o3d MatrixLoadOrder RowMajor
</textarea>
		</div>
    </div>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-431727-3");
pageTracker._trackPageview();
} catch(err) {}</script>
<script type="text/javascript">
_qoptions={
qacct:"p-63KLLGWMOeQhM"
};
</script>
<script type="text/javascript" src="http://edge.quantserve.com/quant.js"></script>
<noscript>
<img src="http://pixel.quantserve.com/pixel/p-63KLLGWMOeQhM.gif" style="display: none;" border="0" height="1" width="1" alt="Quantcast"/>
</noscript>
</body>
</html>
